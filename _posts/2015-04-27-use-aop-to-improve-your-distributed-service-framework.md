---
layout: post
title:  用AOP实现一个简单的布式服务框架
tags:   blogging
image:  micro-service-architecture.jpg
---

大型网站往往把整个网站的业务分成不同的产品线并归不同的业务团队负责，对应的在技术上也会分成很多不同的应用，每个应用自己独立部署维护，应用之间可以通过一个超链接建立关系，可以通过同一域名下的cookie来共享数据，也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储来构成一个关联的完整系统。

但随着拆分的应用越来越多，整个系统的复杂度呈指数级增加，数据存储直接暴露给多个应用共享使得系统变得难以变化和扩展，同时，太多的应用连接相同的数据源很容易导致连接资源的不足。

这个时候，往往会把多个应用都需要执行的许多相同的业务操作提取出来作为服务应用，独立部署，独立地连接数据存储，同时基于某种协议对外提供远程服务。一般的应用系统只需维护界面，后台通过分布式服务调用来完成具体的业务操作即可。分布式服务架构已经成为大型网站系统普遍采用的架构模式，除了解决连接资源不足这样的问题外，更重要的是，它提供了一个更高层次的抽象和封装，隔离了数据存储层的变化——比如现在要更改底层的数据结构、切换数据存储系统（Oracle切换成MySQL或NoSQL）、加入分布式缓存等等——只要对外提供的业务接口没有变化，这些实现形式的优化对外都是透明的。



{{ more }}


### 用AOP来处理服务提供者的非功能需求

一个服务应用往往要对外提供多个业务接口，这些接口除了要提供一些业务功能外，往往还需要实现一些非功能性的需求，比如我们想要知道接口调用的响应时间、可用率等信息，也想通过开关来对接口进行降级控制，另外对于错误处理、权限验证、数据缓存等也有这非常相似的处理方式，此外，以何种协议来提供远程服务也是所有接口的共性问题。这正是AOP编程最擅长的处理的地方。下面是一个例子：

```
@Service(name="sample_user_service", version="2.0+")
@Protocol(name="dubbo")
@Auth(list=${config_center.internal_auth_list})
class UserServcieImpl implements UserService{

	@OneLevelCache(key="all_users", timeout="60s", max="10000")
    @SecondLevelCache(key="all_users")
    @Monitor(key="find_all_users")
    @Switch(key="find_all_users")	
	public List<User> findAllUsers(){
		//查询数据库得到所有的用户数据
        //如果抛出SystemException类型的异常，在统计时会影响方法的可用率
        //如果抛出BizException类型的异常，则是业务的一部分，不会影响方法的可用率
    }
	
}

```


这个接口用注解描述了它很多非功能性需求，剩下要编写的业务只关注业务本身，非常简洁清晰。我们可以把这些注解叫做接口的元数据，当然，它也可以使用配置文件的形式存在。我们举几个例子来说明一下这种做法的好处：

- 在特殊的情况下，我们需要暂时关闭`findAllUsers`这个方法一段时间，我们可用在一个配置中心中把key为`sample_user_service$find_all_users`的开关关闭即可。（由于服务应用也要能水平扩容，所以是无状态的，配置应该集中保存在一个中心上，可用参考：[用Spring和Zookeeper实现中心化的应用配置](http://spring.io/blog/2015/04/21/springone2gx-2014-replay-centralized-application-configuration-with-spring-and-apache-zookeeper "用Spring和Zookeeper实现中心化的应用配置")）。
- 我们以前二级缓存（分布式缓存）用的是memcached，现在改为redis了，我们只需在框架层来修改代码，接口实现里不需要修改任何代码。后来我们程序改为定时同步数据到redis里，这样这个方法里其实不需要编写任何一行代码了——不过为了编译通过还是写了一行`return null`。
- 当我们接口访问超过一亿的时候，为了系统的健壮性考虑，我们开启了一级缓存（本地缓存），并设置了超时时间为60秒，当然如果为了更灵活，可以写成 `timeout=${config_center.sample_user_service$find_all_users_one_cache_timeout}` ，这样在配置中心中可以配置超时时间了。
- 异常的处理在代码的注释里说过了，这里不解释了。
- 由于有元数据，可以自动生成文档，自动做一下检查代码的工具等等
 

### 与SOA相关概念及产品的对比

上面的实现方式的一个主要特点就是简单，其实仔细观察会发现里面体现了很多服务治理和服务质量的东西，这是SOA非常重要的组成部分，在加上服务注册中心、路由跳转及协议转换等就是完整的SOA了。SOA从其诞生起概念就是非常好的，只是最初主要被IBM和微软用在企业应用集成领域，做出的ESB不但没有用起来还几乎成了一个出名的反模式。反倒是互联网后来居上把SOA给发扬光大了，比如国内广泛使用的Dubbo其实也是基于SOA的概念，只是实现上和ESB有不同的取舍而已。即使使用Dubbo上面的例子里的一些元数据也是有其作用的——比如缓存的部分。

其实这个思路和现在的`微服务架构`到时非常的像，不过微服务的内容比这个还要多很多，比如在组织层面对全功能团队及技术上对云计算和Devops是有一定的要求的，目前也不太成熟，但我觉得在未来很有可能是和Dubbo这样架构不同的一种更好的方式。